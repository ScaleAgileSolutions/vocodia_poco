class AIAgentSDK{constructor(t={}){this.agentId=t.agentId,this.serverUrl=t.serverUrl||"https://portal.theconnexus.ai/api",this.livekitUrl=t.livekitUrl||"wss://webrtc.theconnexus.ai",this.mode=t.mode||"voice",this.isConnected=!1,this.isConnecting=!1,this.connectionState="disconnected",this.room=null,this.audioContext=null,this.audioOutputElement=null,this.attachedTracks=new Set,this.socket=null,this.sessionId=null,this.agentInitialized=!1,this.reconnectAttempts=0,this.maxReconnectAttempts=3,this.isReconnecting=!1,this.isCallEnded=!1,this.messageIdCounter=0,this.eventHandlers={connected:[],disconnected:[],connectionStateChanged:[],transcriptReceived:[],dataReceived:[],error:[],audioTrackReceived:[],participantConnected:[],participantDisconnected:[],messageReceived:[],messageChunk:[],typing:[],sessionInitialized:[]},this.connect=this.connect.bind(this),this.disconnect=this.disconnect.bind(this),this.sendMessage=this.sendMessage.bind(this),this.init()}async init(){if(!this.agentId)throw new Error("Agent ID is required");"voice"===this.mode&&await this.loadLiveKit()}async loadLiveKit(){return new Promise(((t,e)=>{if(window.LivekitClient)return void t(window.LivekitClient);const i=document.createElement("script");i.src="https://cdn.jsdelivr.net/npm/livekit-client/dist/livekit-client.umd.min.js",i.crossOrigin="anonymous",i.onload=()=>{const e=()=>{window.LivekitClient?t(window.LivekitClient):setTimeout(e,100)};e()},i.onerror=()=>e(new Error("Failed to load LiveKit client")),document.head.appendChild(i)}))}on(t,e){if(!this.eventHandlers[t])throw new Error(`Unknown event: ${t}`);return this.eventHandlers[t].push(e),this}off(t,e){if(this.eventHandlers[t]){const i=this.eventHandlers[t].indexOf(e);i>-1&&this.eventHandlers[t].splice(i,1)}return this}emit(t,...e){this.eventHandlers[t]&&this.eventHandlers[t].forEach((i=>{try{i(...e)}catch(e){console.error(`Error in event handler for ${t}:`,e)}}))}async connect(){if(this.isConnected||this.isConnecting)console.warn("Already connected or connecting");else{this.isConnecting=!0,this.updateConnectionState("connecting");try{if("voice"===this.mode){const t=await fetch(`${this.serverUrl}/create-call`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({agent_id:this.agentId,mode:this.mode})});if(!t.ok)throw new Error(`Server responded with ${t.status}: ${t.statusText}`);const e=await t.json();if(!e||!e.token)throw new Error("Failed to get connection token from server");await this.connectVoice(e.token)}else await this.connectText()}catch(t){throw this.isConnecting=!1,this.updateConnectionState("failed"),this.emit("error",t),t}}}async connectVoice(t){const e=window.LivekitClient,{Room:i,RoomEvent:n,ConnectionState:s,createLocalTracks:o,Track:a,DataPacket_Kind:c}=e;try{await navigator.mediaDevices.getUserMedia({audio:!0})}catch(t){throw new Error("Microphone access denied. Please grant permission and try again.")}this.room=new i({adaptiveStream:!0,dynacast:!0}),this.room.on(n.ConnectionStateChanged,(t=>{this.updateConnectionState(t),t===s.Connected?(this.isConnected=!0,this.isConnecting=!1,this.emit("connected")):t===s.Disconnected?this.handleDisconnection():t===s.Failed&&this.emit("error",new Error("Connection failed"))})).on(n.DataReceived,((t,e,i,n)=>{const s=(new TextDecoder).decode(t);this.emit("dataReceived",{topic:n,message:s,participant:e?.identity})})).on(n.TranscriptionReceived,((t,e)=>{this.emit("transcriptReceived",{segments:t,participant:e?.identity,isUser:"client-participant"===e?.identity})})).on(n.ParticipantConnected,(t=>{this.emit("participantConnected",t?.identity)})).on(n.ParticipantDisconnected,(t=>{this.emit("participantDisconnected",t?.identity),"client-participant"!==t?.identity&&this.disconnect()})).on(n.TrackSubscribed,((t,e,i)=>{t.kind===a.Kind.Audio&&(console.log("Audio track subscribed:",t.sid),this.attachAudioTrack(t),this.emit("audioTrackReceived",{track:t,participant:i?.identity}))})).on(n.TrackUnsubscribed,((t,e,i)=>{t.kind===a.Kind.Audio&&(console.log("Audio track unsubscribed:",t.sid),this.detachAudioTrack(t))})),await this.room.connect(this.livekitUrl,t);const d=(await o({audio:{sampleRate:24e3,channelCount:1,echoCancellation:!0,noiseSuppression:!0},video:!1})).find((t=>t.kind===a.Kind.Audio));d&&await this.room.localParticipant.publishTrack(d)}async connectText(t){return new Promise(((t,e)=>{try{this.socket&&this.socket.readyState===WebSocket.OPEN&&this.socket.close(),this.agentInitialized=!1,this.reconnectAttempts=0,this.isReconnecting=!1,this.isCallEnded=!1;const i=`${this.serverUrl.replace("http://","ws://").replace("https://","wss://")}/chat/v1/${this.agentId}?communication_type=text`,n=this.sessionId&&this.isReconnecting?`${i}&reconnect_session_id=${this.sessionId}`:i;console.log("SDK connecting to text WebSocket:",n),this.socket=new WebSocket(n),this.socket.onopen=()=>{console.log("SDK text WebSocket connected"),this.isConnected=!0,this.isConnecting=!1,this.reconnectAttempts=0,this.isReconnecting=!1,this.updateConnectionState("connected");const e={type:"text-chat-init",data:{agentId:this.agentId,userId:`user-${Date.now()}`,dynamic_variables:{}}};this.socket.send(JSON.stringify(e)),this.emit("connected"),t()},this.socket.onmessage=t=>{try{const e=JSON.parse(t.data);this.handleTextMessage(e)}catch(t){console.error("Error parsing WebSocket message:",t),this.emit("error",new Error("Failed to parse WebSocket message"))}},this.socket.onclose=t=>{console.log("SDK text WebSocket closed:",t.code,t.reason),this.isConnected=!1,this.isCallEnded?this.emit("disconnected"):(1e3!==t.code&&this.sessionId&&this.agentInitialized&&this.reconnectAttempts<this.maxReconnectAttempts&&!this.isReconnecting?this.attemptTextReconnection():this.reconnectAttempts>=this.maxReconnectAttempts?(this.emit("error",new Error("Connection lost after 3 retry attempts")),this.sessionId=null):this.agentInitialized||this.emit("error",new Error("Agent failed to initialize")),this.handleDisconnection())},this.socket.onerror=t=>{console.error("SDK text WebSocket error:",t),this.emit("error",new Error("WebSocket connection error")),e(t)}}catch(t){this.emit("error",t),e(t)}}))}handleTextMessage(t){switch(console.log("SDK received text message:",t),t.type){case"session_initialized":this.sessionId=t.session_id,this.agentInitialized=!0,this.emit("sessionInitialized",{sessionId:this.sessionId}),console.log("SDK session initialized:",this.sessionId);break;case"reconnection_success":this.agentInitialized=!0,console.log("SDK reconnection successful");break;case"text-chat-connected":this.agentInitialized=!0,console.log("SDK text chat connected");break;case"text-chat-typing":this.emit("typing",{isTyping:t.data.typing});break;case"text-chat-chunk":this.handleTextChunk(t);break;case"text-chat-message-complete":this.emit("messageReceived",{type:"complete",messageId:t.data.messageId,timestamp:t.data.timestamp});break;case"text-chat-error":this.emit("error",new Error(t.data.error||"An error occurred during the conversation"));break;case"end-call":this.handleTextCallEnded()}}handleTextChunk(t){let e=t.data.chunk||"";if(e=e.replace(/<beginning_of_stream>/g,""),e=e.replace(/<end_of_stream>/g,""),e=e.trim(),e){const i=t.data.messageId||"assistant-"+ ++this.messageIdCounter;this.emit("messageChunk",{messageId:i,content:e,timestamp:t.data.timestamp||Date.now(),isComplete:t.data.chunk&&t.data.chunk.includes("<end_of_stream>")}),this.emit("messageReceived",{id:i,role:"assistant",content:e,timestamp:t.data.timestamp||Date.now()})}}async attemptTextReconnection(){if(!this.isReconnecting&&this.sessionId){this.isReconnecting=!0,this.reconnectAttempts++;try{const t=await fetch(`${this.serverUrl}/chat/v1/session/${this.sessionId}/status`);if(!t.ok)throw new Error(`Session status check failed: ${t.status}`);if(!(await t.json()).canReconnect)return this.sessionId=null,this.isReconnecting=!1,void this.emit("error",new Error("Session expired. Please start a new conversation."));await new Promise((t=>setTimeout(t,2e3*this.reconnectAttempts))),await this.connectText()}catch(t){console.error("Error during SDK text reconnection attempt:",t),this.isReconnecting=!1,this.reconnectAttempts>=this.maxReconnectAttempts?(this.emit("error",new Error("Failed to reconnect after 3 attempts")),this.sessionId=null):setTimeout((()=>{this.attemptTextReconnection()}),2e3*this.reconnectAttempts)}}}handleTextCallEnded(){this.isCallEnded=!0,setTimeout((()=>{this.sessionId=null,this.isReconnecting=!1,this.socket&&this.socket.readyState===WebSocket.OPEN&&this.socket.close(1e3,"Call ended"),this.socket=null,this.isConnected=!1,this.updateConnectionState("disconnected"),this.emit("disconnected")}),2e3)}sendMessage(t){if("text"!==this.mode)throw new Error("sendMessage is only available in text mode");if(!this.socket||this.socket.readyState!==WebSocket.OPEN)throw new Error("Not connected to text agent");const e={type:"text-chat-message",data:{message:t,timestamp:Date.now()}};this.socket.send(JSON.stringify(e)),this.emit("messageReceived",{id:"user-"+ ++this.messageIdCounter,role:"user",content:t,timestamp:Date.now()})}sendData(t,e){if("voice"===this.mode&&this.room){const i=(new TextEncoder).encode(JSON.stringify(e));this.room.localParticipant.publishData(i,DataPacket_Kind.RELIABLE,t)}else{if("text"!==this.mode||!this.socket)throw new Error("Not connected");this.socket.send(JSON.stringify({type:"data",topic:t,data:e,timestamp:Date.now()}))}}async disconnect(){(this.isConnected||this.isConnecting)&&(this.isConnected=!1,this.isConnecting=!1,this.cleanupAudioTracks(),"voice"===this.mode&&this.room?(await this.room.disconnect(),this.room=null):"text"===this.mode&&this.socket&&(this.sessionId=null,this.isReconnecting=!1,this.isCallEnded=!1,this.agentInitialized=!1,this.reconnectAttempts=0,this.socket.close(),this.socket=null),this.audioContext&&"closed"!==this.audioContext.state&&(await this.audioContext.close(),this.audioContext=null),this.updateConnectionState("disconnected"))}handleDisconnection(){this.isConnected=!1,this.isConnecting=!1,this.updateConnectionState("disconnected"),this.emit("disconnected")}updateConnectionState(t){const e=this.connectionState;this.connectionState=t,this.emit("connectionStateChanged",{state:t,previousState:e})}getConnectionState(){return{isConnected:this.isConnected,isConnecting:this.isConnecting,connectionState:this.connectionState,mode:this.mode,audioTracksCount:this.attachedTracks?this.attachedTracks.size:0}}getAudioStatus(){if("voice"!==this.mode)return{mode:this.mode,message:"Audio not available in text mode"};const t=this.attachedTracks?this.attachedTracks.size:0,e=!!this.audioOutputElement,i=!!this.defaultAudioContainer,n=[];return this.attachedTracks&&this.attachedTracks.forEach((({track:t,element:e})=>{n.push({trackId:t.sid,isPaused:e.paused,volume:e.volume,muted:e.muted,hasParent:!!e.parentNode})})),{mode:this.mode,attachedTracksCount:t,hasAudioOutput:e,hasDefaultContainer:i,audioElements:n,audioContextState:this.audioContext?this.audioContext.state:"none"}}attachAudioTrack(t){try{const e=t.attach();e.autoplay=!0,e.playsInline=!0;const i=e.play();if(void 0!==i&&i.catch((t=>{console.warn("Audio autoplay was prevented:",t),this.emit("error",new Error("Audio autoplay blocked. User interaction may be required."))})),this.attachedTracks.add({track:t,element:e}),this.audioOutputElement?this.audioOutputElement.appendChild(e):(this.defaultAudioContainer||(this.defaultAudioContainer=document.createElement("div"),this.defaultAudioContainer.style.display="none",document.body.appendChild(this.defaultAudioContainer)),this.defaultAudioContainer.appendChild(e)),console.log("Audio track attached successfully"),!this.audioContext)try{this.audioContext=new(window.AudioContext||window.webkitAudioContext)}catch(t){console.warn("Could not create AudioContext:",t)}}catch(t){console.error("Error attaching audio track:",t),this.emit("error",new Error(`Failed to attach audio track: ${t.message}`))}}detachAudioTrack(t){const e=Array.from(this.attachedTracks).find((e=>e.track===t));e&&(e.element&&e.element.parentNode&&e.element.parentNode.removeChild(e.element),this.attachedTracks.delete(e),console.log("Audio track detached"))}cleanupAudioTracks(){this.attachedTracks.forEach((({element:t})=>{t&&t.parentNode&&t.parentNode.removeChild(t)})),this.attachedTracks.clear(),this.defaultAudioContainer&&this.defaultAudioContainer.parentNode&&(this.defaultAudioContainer.parentNode.removeChild(this.defaultAudioContainer),this.defaultAudioContainer=null),console.log("Audio tracks cleaned up")}setAudioOutput(t){"voice"===this.mode?(this.audioOutputElement=t,this.attachedTracks.forEach((({element:e})=>{e.parentNode&&e.parentNode.removeChild(e),t.appendChild(e)})),console.log("Audio output element set")):console.warn("setAudioOutput is only relevant for voice mode")}async destroy(){await this.disconnect(),this.cleanupAudioTracks(),Object.keys(this.eventHandlers).forEach((t=>{this.eventHandlers[t]=[]})),this.room=null,this.socket=null,this.audioContext=null,this.audioOutputElement=null,this.defaultAudioContainer=null,this.attachedTracks=null}}"undefined"!=typeof module&&module.exports?module.exports=AIAgentSDK:"undefined"!=typeof window&&(window.AIAgentSDK=AIAgentSDK);